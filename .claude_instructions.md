# Claude Code Instructions for TrustQuery Trace Integration

## Overview
This document provides instructions for integrating the TrustQuery Trace library into the trustquery.com node server. When a CSV file is added to a prompt, the system should automatically generate TQL files and in-memory JSON representations.

## Repository Structure

### Key Files
- **CLI Entry**: `bin/run.js`
- **Main Exports**: `src/index.ts`
- **CSV Reader**: `src/lib/readers/csv.ts`
- **TQL Generators**: `src/lib/generators/index.ts`
- **CRUD Operations**: `src/lib/operations/crud.ts`
- **Type Definitions**: `src/lib/parser/types.ts`

### Available Commands
```bash
tql create --source csv --in <file.csv> --out <file.tql> [--format json]
tql insert --file <file.tql> --facet <facet-name> --data <json>
tql update --file <file.tql> --facet <facet-name> --index <n> --data <json>
tql delete --file <file.tql> --facet <facet-name> --index <n>
tql get --file <file.tql> --facet <facet-name> [--index <n>]
```

## Integration Approach

### 1. Install as NPM Package
```bash
npm install @trustquery/trace
```

Or link locally for development:
```bash
cd /path/to/trustquery-trace
npm link

cd /path/to/trustquery.com
npm link @trustquery/trace
```

### 2. Import in Node Server
```typescript
import {
  generateTqlDocument,
  parseTql,
  readCsv,
  writeTql,
  writeTqlJson,
  insertRowInMemory,
  updateRowInMemory,
  deleteRowInMemory,
  applyChangesToConversation,
  type TqlConversation,
  type TqlDocument
} from '@trustquery/trace'
```

### 3. CSV Processing Flow

When a CSV file is uploaded or provided in a prompt:

```typescript
// Step 1: Read CSV file
const csvData = readCsv('/path/to/file.csv')
// Returns: { headers: string[], rows: string[][] }

// Step 2: Generate TQL Document (with all 9 facets)
const tqlDocument = generateTqlDocument({
  source: {
    format: 'csv',
    data: {
      headers: csvData.headers,
      rows: csvData.rows,
    },
  },
  facet: { name: '@table' },
  query: 'Optional user query here'  // Include if user asks a question
})

// Step 3: Wrap in Conversation
const conversation: TqlConversation = {
  sequence: [
    { '#document[+0]': tqlDocument }
  ]
}

// Step 4A: Generate TQL markdown file
writeTql('/path/to/output.tql', conversation)

// Step 4B: Get JSON representation for in-memory use
const jsonRepresentation = conversation
// Or write to file:
writeTqlJson('/path/to/output.json', conversation)
```

### 4. In-Memory JSON Structure

The `TqlDocument` contains 9 facets:

```typescript
interface TqlDocument {
  table: { rows: Array<{index: number, [column: string]: string | number}> }
  meaning: { rows: Array<{index: number, column: string, definition: string}> }
  structure: { rows: Array<{index: number, column: string, dataType: string, format: string, minValue: string, maxValue: string, nullAllowed: string}> }
  ambiguity: { rows: Array<{index: number, query_trigger: string, ambiguity_type: string, ambiguity_risk: string}> }
  intent: { rows: Array<{index: number, query_trigger: string, clarifying_question: string, options: string, user_response: string, user_confirmed: string}> }
  context: { rows: Array<{index: number, key: string, value: string}> }
  query: { rows: Array<{index: number, user_message: string, timestamp_utc: string}> }
  tasks: { rows: Array<{index: number, name: string, description: string, formula: string}> }
  score: { rows: Array<{index: number, measure: string, value: string}> }
}
```

### 5. CRUD Operations with Automatic Diff Tracking

Use the in-memory CRUD operations for modifications:

```typescript
import { applyChangesToConversation, insertRowInMemory, updateRowInMemory } from '@trustquery/cli'

// Apply changes with automatic diff tracking
const updatedConversation = applyChangesToConversation(conversation, (doc) => {
  // Insert context information
  insertRowInMemory(doc, 'context', {
    key: 'user_timezone',
    value: 'PST'
  })

  // Update meaning definitions
  updateRowInMemory(doc, 'meaning', 2, {
    definition: 'ISO 8601 timestamp format'
  })

  // Add task computation
  insertRowInMemory(doc, 'tasks', {
    name: 'total_amount',
    description: 'Sum of all transaction amounts',
    formula: 'SUM(amount_usd)'
  })
})

// The updatedConversation now has:
// - sequence[0]: original #document[+0]
// - sequence[1]: new #document[+1] with changes
// - sequence[2]: $diff[+0→+1] showing what changed
```

### 6. Server Endpoint Example

```typescript
import express from 'express'
import multer from 'multer'
import { readCsv, generateTqlDocument, writeTql, writeTqlJson } from '@trustquery/trace'

const app = express()
const upload = multer({ dest: 'uploads/' })

app.post('/process-csv', upload.single('csv'), async (req, res) => {
  try {
    const csvPath = req.file.path
    const userQuery = req.body.query || ''

    // Read CSV
    const csvData = readCsv(csvPath)

    // Generate TQL Document
    const tqlDocument = generateTqlDocument({
      source: { format: 'csv', data: csvData },
      facet: { name: '@table' },
      query: userQuery
    })

    // Create conversation
    const conversation = {
      sequence: [{ '#document[+0]': tqlDocument }]
    }

    // Generate output files
    const tqlPath = `outputs/${Date.now()}.tql`
    const jsonPath = `outputs/${Date.now()}.json`

    writeTql(tqlPath, conversation)
    writeTqlJson(jsonPath, conversation)

    // Return both representations
    res.json({
      success: true,
      tqlFile: tqlPath,
      jsonFile: jsonPath,
      data: conversation,
      stats: {
        columns: csvData.headers.length,
        rows: csvData.rows.length
      }
    })
  } catch (error) {
    res.status(500).json({ error: error.message })
  }
})

app.listen(3000)
```

### 7. Parsing Existing TQL Files

To parse existing TQL files back to JSON:

```typescript
import { parseTql, parseTqlConversationFromString } from '@trustquery/trace'
import fs from 'fs'

// From file path
const conversation = parseTql('/path/to/file.tql')

// From string
const tqlContent = fs.readFileSync('/path/to/file.tql', 'utf-8')
const conversation = parseTqlConversationFromString(tqlContent)

// Access the latest document
import { getLastDocument } from '@trustquery/trace'
const latestDoc = getLastDocument(conversation)

// Access specific facets
const tableData = latestDoc.table.rows
const contextData = latestDoc.context.rows
```

## Common Use Cases

### Use Case 1: CSV Upload with Query
```typescript
// User uploads CSV and asks: "What was the total amount transferred?"
const csvData = readCsv(csvPath)
const doc = generateTqlDocument({
  source: { format: 'csv', data: csvData },
  facet: { name: '@table' },
  query: 'What was the total amount transferred?'
})

// The @query facet will contain the user's question with timestamp
```

### Use Case 2: Add User Context
```typescript
// Add timezone or user information to context facet
insertRowInMemory(doc, 'context', { key: 'user_timezone', value: 'EST' })
insertRowInMemory(doc, 'context', { key: 'user_email', value: 'user@example.com' })
```

### Use Case 3: Define Column Meanings
```typescript
// Clarify what columns mean
updateRowInMemory(doc, 'meaning', 1, {
  definition: 'Unique transaction identifier in format TXN-YYYY-NNN'
})
updateRowInMemory(doc, 'meaning', 2, {
  definition: 'Transaction timestamp in ISO 8601 UTC format'
})
```

### Use Case 4: Track Ambiguities
```typescript
// Identify ambiguities for the AI to resolve
insertRowInMemory(doc, 'ambiguity', {
  query_trigger: 'What was the total amount?',
  ambiguity_type: 'currency_ambiguity',
  ambiguity_risk: 'high'
})

insertRowInMemory(doc, 'intent', {
  query_trigger: 'What was the total amount?',
  clarifying_question: 'Which currency should I use for the total?',
  options: 'USD, EUR, BTC',
  user_response: 'USD',
  user_confirmed: 'true'
})
```

### Use Case 5: Add Computational Tasks
```typescript
// Define calculations to perform
insertRowInMemory(doc, 'tasks', {
  name: 'total_usd',
  description: 'Sum of all amounts in USD',
  formula: 'SUM(amount_usd)'
})

insertRowInMemory(doc, 'tasks', {
  name: 'avg_transaction',
  description: 'Average transaction amount',
  formula: 'AVG(amount_usd)'
})
```

## Important Notes

1. **All 9 Facets**: Every TQL document contains all 9 facets, even if some are empty
2. **Automatic Indexing**: Row indices are automatically managed (1-based)
3. **Diff Tracking**: Use `applyChangesToConversation()` for automatic diff generation
4. **Immutable Updates**: CRUD operations create new documents, preserving history
5. **Type Safety**: Import TypeScript types from `@trustquery/cli` for full type safety

## File Locations Reference

- Main exports: `src/index.ts`
- CSV reader: `src/lib/readers/csv.ts:1`
- TQL generators: `src/lib/generators/index.ts:1`
- CRUD operations: `src/lib/operations/crud.ts:1`
- Type definitions: `src/lib/parser/types.ts:1`
- CLI create command: `src/commands/create.ts:1`

## Testing

Run examples to verify integration:
```bash
cd trustquery-language
npm run example
```

This will process `examples/stablecoin.csv` and show the full workflow.

## Summary

When integrating with trustquery.com:
1. Install `@trustquery/trace` as a dependency
2. Import `readCsv`, `generateTqlDocument`, `writeTql`, and CRUD functions
3. Process uploaded CSVs through the pipeline: CSV → TQL Document → Conversation
4. Store both TQL markdown (human-readable) and JSON (machine-readable) formats
5. Use in-memory operations for modifications with automatic diff tracking
6. Return the JSON representation for API responses
7. Save TQL files for audit trails and conversation history

## About TrustQuery Trace

TrustQuery Trace is like LangSmith for data instead of models - it traces data disambiguation conversations with versioned semantic annotations. Each `TqlConversation` is a trace log showing how ambiguous data becomes clear over time.
